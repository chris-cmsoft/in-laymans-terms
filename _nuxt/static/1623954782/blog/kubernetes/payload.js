__NUXT_JSONP__("/blog/kubernetes", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab){return {data:[{article:{slug:p,description:"Kubernetes is a container orchestrator",title:q,categories:["api","web"],author:{name:"Chris"},toc:[{id:r,depth:k,text:s},{id:t,depth:k,text:u},{id:v,depth:k,text:w},{id:x,depth:k,text:y},{id:z,depth:k,text:A},{id:B,depth:k,text:C},{id:D,depth:k,text:E},{id:F,depth:k,text:G},{id:H,depth:k,text:I},{id:J,depth:k,text:K},{id:L,depth:k,text:M},{id:N,depth:k,text:n},{id:O,depth:k,text:P},{id:Q,depth:k,text:R},{id:S,depth:k,text:T},{id:U,depth:k,text:V},{id:W,depth:k,text:X},{id:Y,depth:k,text:Z},{id:_,depth:k,text:$}],body:{type:"root",children:[{type:b,tag:d,props:{},children:[{type:a,value:"Saying Kubernetes is a container orchestrator often confuses people,\nand does not make sense to new comers to the Container Orchestration world."},{type:b,tag:o,props:{},children:[]},{type:a,value:"\nSo I'll try to explain Kubernetes here in more concrete terms, and why it exists."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"This is not an exhaustive guide to the inner workings of Kubernetes,"},{type:b,tag:o,props:{},children:[]},{type:a,value:"\nbut rather a look into why it exists at all, and what it's essential purpose is."}]},{type:a,value:c},{type:b,tag:"blockquote",props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Kubernetes, also known as K8s, is an open-source system for automating deployment,\nscaling, and management of containerized applications."},{type:b,tag:o,props:{},children:[]},{type:a,value:"\n- "},{type:b,tag:e,props:{href:aa,rel:["nofollow","noopener","noreferrer"],target:"_blank"},children:[{type:a,value:aa}]}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:m,props:{id:"from-the-start"},children:[{type:b,tag:e,props:{href:"#from-the-start",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:"From the start"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Kubernetes solves a problem that has existed for quite some time in the software world."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Orchestrating distributed systems."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"To understand the problem that Kubernetes solves, let's have a look at where it originated from."}]},{type:a,value:c},{type:b,tag:l,props:{id:r},children:[{type:b,tag:e,props:{href:"#a-traditional-deployment",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:s}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"If you've built an application, and run it before,\nyou'll likely have deployed this application on a virtual machine or server,\nand exposed it through a public IP or domain name."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"These applications could have multiple parts or pieces (Frontend, Backend, Queue processors),\neach with their own running processes and computing requirements."}]},{type:a,value:c},{type:b,tag:l,props:{id:t},children:[{type:b,tag:e,props:{href:"#updating-a-traditional-deployment",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:u}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"If you want to update the code of a traditional deployment,\nyou would typically SSH onto the server where it is deployed,\nupdate the codebase through Git or another version control system,\nupdate all of the packages (if interpreted language is used),\nrestart the web server if it has changes,\nand viola, your application is updated."}]},{type:a,value:c},{type:b,tag:l,props:{id:v},children:[{type:b,tag:e,props:{href:"#scaled-traditional-deployment",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:w}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"The traditional model is quite simple. Now let's consider that we start seeing some scale."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Our user base has grown and you need some more servers to handle the load.\nNot for all of the parts of your application, but only for certain parts."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Let's say for example the queue processors, and the API."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"So we add a second server, deploy the code, hook it up to the Queue,\ndeploy the web server, and start processing extra background jobs and requests."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"We also add a load balancer in front of our servers,\nso the load is split across all our servers for the API."}]},{type:a,value:c},{type:b,tag:l,props:{id:x},children:[{type:b,tag:e,props:{href:"#updating-a-scaled-traditional-deployment",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:y}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"When we now want to update our application, we need to ssh into each of our servers,\nupdate the codebase, and restart everything."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Our updates are still fairly simple to manage, but we have to look after these servers."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"When we update server packages for security updates for example,\nwe need to install new packages, and reboot our servers."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"We now have downtime included as well. We have a bit of time during our application updates and server reboots,\nwhere some of our application is not accessible."}]},{type:a,value:c},{type:b,tag:l,props:{id:z},children:[{type:b,tag:e,props:{href:"#zero-downtime-updates-in-a-scaled-traditional-deployment",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:A}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"We would not like to do application updates without downtime,\nso our application remains accessible throughout updates."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"So we go ahead and add 1 more server, to replicate our first server,\nadd it to the load balancer."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Then during updates, we remove the updating server from the load balancer,\nupdate and reboot it, and then add it back to the load balancer."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"We need to do this for every server, keeping in mind that they might have different components,\nand that each server might need to be treated differently."}]},{type:a,value:c},{type:b,tag:l,props:{id:B},children:[{type:b,tag:e,props:{href:"#more-applications",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:C}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"As our business keeps growing, we have more and more applications or APIs, or even microservices\nthat need to be deployed. So we reuse the infrastructure we have, and deploy these onto our existing servers\nto keep networking and server updates simple, and update our procedures for updating all the applications."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"We now have a big jumble of apis deployed across our server fleet."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"We need a way to make the deployments simpler, as deploying one of our applications\nbrings downtime for our other applications which reside on the same machine."}]},{type:a,value:c},{type:b,tag:m,props:{id:"containers"},children:[{type:b,tag:e,props:{href:"#containers",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:n}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"So we start packaging all of our applications in "},{type:b,tag:"nuxt-link",props:{to:"\u002Fblog\u002Fcontainer"},children:[{type:a,value:n}]},{type:a,value:",\nto more easily manage their dependencies, and more easily update our application code on our servers."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Instead of heaving to pull code and update packages and restart processes directly on the servers,\nwe can build each of these separately, and simply pull the new images onto the servers, update the configs,\nand restart the containers."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"The only time we need to restart the servers, is when we have updates to the servers themselves."}]},{type:a,value:c},{type:b,tag:l,props:{id:D},children:[{type:b,tag:e,props:{href:"#updating-scaled-container-deployments",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:E}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"When we want to update applications, we now need to SSH onto all of the servers where the application is running,\nand pull the new image for teh application, and restart the container for that particular application."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"There are two things which are hard about this process."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"We have to find only the servers where this application is running,"},{type:b,tag:o,props:{},children:[]},{type:a,value:"\nand we need to know the correct command and settings for the specific container."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"If containers are sufficiently complex (Volumes, Networks, Port mappings), this process can be quite error prone."}]},{type:a,value:c},{type:b,tag:l,props:{id:F},children:[{type:b,tag:e,props:{href:"#declarative-configuration",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:G}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"To solve the error prone problem we have when updating containers, we use a method called declarative config."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Declarative configuration is where we specify all of the settings for the container,\nin a file. Usually this is a json or yaml file."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"In this file, we can specify all of the volume mounts, networks, ports, images etc."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"We can then use this file to keep our settings in, and update it before we run our new application."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"This helps us avoid errors, as well as make it easy to review changes when we update the fie for new changes."}]},{type:a,value:c},{type:b,tag:m,props:{id:"orchestration"},children:[{type:b,tag:e,props:{href:"#orchestration",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:"Orchestration"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"We still have the problem of having to copy declarative files to the correct servers,\nand running the new containers."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"There is still a lot of manual effort involved, and this process could be easily automated."}]},{type:a,value:c},{type:b,tag:l,props:{id:H},children:[{type:b,tag:e,props:{href:"#dynamic-changes-in-traffic",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:I}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Imagine we have scale that goes up and down, or applications that need more processing during the day,\nand queues that need more processing at certain times."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"For the quiet times, we have too much processing power, and for busy times,\nwe sometimes have to move containers around to make sure there is enough processing power for everybody."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"If a server gets too busy, we need to move some containers to other servers, which aren't as busy."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"If a particular server starts failing, we need to make sure we reschedule the containers that were running there,\nto a new server, or to the servers which are all still healthy."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"All of this takes a lot of manual effort."}]},{type:a,value:c},{type:b,tag:l,props:{id:J},children:[{type:b,tag:e,props:{href:"#networking-for-dynamic-changes",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:K}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"When we start moving applications around for different reasons,\nwe need to administer the load balancer to send traffic to the correct servers which have to correct applications."}]},{type:a,value:c},{type:b,tag:l,props:{id:L},children:[{type:b,tag:e,props:{href:"#automated-health-checks",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:M}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"When we start implementing solutions like Health checks, or smoke tests,\nso we can automatically switch the load balancer to healthy servers,\nwe need to administer this to point it at all the available applications,\nas well as add and remove any applications which are no longer there or available."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"This becomes a very big manual effort when you consider adding more automated checks or monitoring."}]},{type:a,value:c},{type:b,tag:m,props:{id:p},children:[{type:b,tag:e,props:{href:"#kubernetes",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:q}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"This is where an orchestration tool like Kubernetes steps in."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Kubernetes is a tool, which allows us to update containers using an API, and declarative files,\nand manage all our applications much more simply."}]},{type:a,value:c},{type:b,tag:l,props:{id:N},children:[{type:b,tag:e,props:{href:"#containers-1",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:n}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"At the core of Kubernetes is containers.\nIt starts, stops, updates, and removes containers from a cluster of servers."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"If you want an application deployed onto the servers,\nyou can ask Kubernetes to deploy a container onto your fleet of servers."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Kubernetes will then look through your servers, find which server is best for adding the container to,\nand run it there."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"You can also ask Kubernetes to deploy for example, 5 replicas of your container,\nand it will find the best servers where your containers will fit,\nand create 5 containers for you on the appropriate servers."}]},{type:a,value:c},{type:b,tag:l,props:{id:O},children:[{type:b,tag:e,props:{href:"#networking",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:P}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Earlier we spoke about having to update a load balancer to remove an updating application."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Kubernetes does this automatically too,\nby updating it's Endpoints to no longer include the updating containers IP,\nwhich in turn means it is no longer included in the pool of containers for the application."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"It also sets up networking in such a way, that no matter which one of your servers you call,\nit will route your request to a server which has your application on it."}]},{type:a,value:c},{type:b,tag:l,props:{id:Q},children:[{type:b,tag:e,props:{href:"#rolling-updates",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:R}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"If setup correctly, when Kubernetes updates your application, it will add the new container,\nwithout removing the previous container, update the networking which points at the container to include the new container,\nand remove the old container, and continue onto updating the next container."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"This is referred to as a RollingUpdate."}]},{type:a,value:c},{type:b,tag:l,props:{id:S},children:[{type:b,tag:e,props:{href:"#configuration",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:T}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Kubernetes also has capabilities to specify your application configurations,\nand include them in your containers. This means that you don't need to make sure that\nyou configuration is available on all of your servers, but rather specify it once,\nand let Kubernetes take care of putting it in all the right places."}]},{type:a,value:c},{type:b,tag:l,props:{id:U},children:[{type:b,tag:e,props:{href:"#secrets",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:V}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Kubernetes has a secret system built in, by which you can semi-securely add secrets for your applications,\nlike database passwords, or application keys, without having to specify them in your declarative files."}]},{type:a,value:c},{type:b,tag:l,props:{id:W},children:[{type:b,tag:e,props:{href:"#dynamic-updates",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:X}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Kubernetes has built in mechanisms to ensure your desired state is continually reconciled."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"This means that if for example, one of your servers fails or goes offline,\nKubernetes will move all of the containers running on that server,\nto other servers which are healthy and have enough capacity to accept these new containers."}]},{type:a,value:c},{type:b,tag:l,props:{id:Y},children:[{type:b,tag:e,props:{href:"#scaling-applications",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:Z}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Kubernetes allows you to easily scale up or down containers,\nby simply updating how many replicas you would like."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Kubernetes then takes care of adding more containers on your servers,\nor removing some of them if you've scaled down."}]},{type:a,value:c},{type:b,tag:m,props:{id:"misconceptions"},children:[{type:b,tag:e,props:{href:"#misconceptions",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:"Misconceptions"}]},{type:a,value:c},{type:b,tag:l,props:{id:_},children:[{type:b,tag:e,props:{href:"#kubernetes-handles-incoming-traffic",ariaHidden:f,tabIndex:g},children:[{type:b,tag:h,props:{className:[i,j]},children:[]}]},{type:a,value:$}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"There is a misconception, especially for Kubernetes new comers,\nthat Kubernetes handles traffic which is destined for our applications."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"This is not true. It uses Linux tools to direct traffic, but if our Kubernetes servers go down,\nand your workload servers stay up, your application will continue to work,\nbut you will no longer be able to make updates to your application."}]}]},dir:"\u002Farticles",path:"\u002Farticles\u002Fkubernetes",extension:".md",createdAt:ab,updatedAt:ab},prev:{slug:"grep",title:"Grep"},next:{slug:"platform",title:"Platform"}}],fetch:{},mutations:void 0}}("text","element","\n","p","a","true",-1,"span","icon","icon-link",2,"h2","h1","Containers","br","kubernetes","Kubernetes","a-traditional-deployment","A traditional deployment","updating-a-traditional-deployment","Updating a traditional deployment","scaled-traditional-deployment","Scaled traditional deployment","updating-a-scaled-traditional-deployment","Updating a scaled traditional deployment","zero-downtime-updates-in-a-scaled-traditional-deployment","Zero downtime updates in a scaled traditional deployment","more-applications","More applications","updating-scaled-container-deployments","Updating scaled container deployments","declarative-configuration","Declarative configuration","dynamic-changes-in-traffic","Dynamic changes in traffic","networking-for-dynamic-changes","Networking for dynamic changes","automated-health-checks","Automated Health checks","containers-1","networking","Networking","rolling-updates","Rolling updates","configuration","Configuration","secrets","Secrets","dynamic-updates","Dynamic updates","scaling-applications","Scaling applications","kubernetes-handles-incoming-traffic","Kubernetes handles incoming traffic","https:\u002F\u002Fkubernetes.io\u002F","2021-06-17T18:32:05.177Z")));